{"version":3,"sources":["components/ColorSquare.js","components/Palette.js","components/Ship.js","App.js","serviceWorker.js","index.js"],"names":["ColorSquare","props","color","react_default","a","createElement","className","style","backgroundColor","concat","Palette","colors","this","map","components_ColorSquare","key","Component","Ship","data","name","src_components_Palette","App","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","ships","getData","_this2","fetch","then","response","json","setState","palettes","item","ind","components_Ship","React","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"wSAoBeA,MAhBf,SAAqBC,GAAO,IAClBC,EAAUD,EAAVC,MACR,OACEC,EAAAC,EAAAC,cAAA,MACEC,UAAU,cACVC,MAAO,CACLC,gBAAe,IAAAC,OAAMP,OCadQ,0LAhBJ,IACCC,EAAWC,KAAKX,MAAhBU,OACR,OACER,EAAAC,EAAAC,cAAA,MAAIC,UAAU,WACXK,EAAOE,IAAI,SAAAX,GAAK,OACfC,EAAAC,EAAAC,cAACS,EAAD,CAAaC,IAAKb,EAAOA,MAAOA,cANpBc,cCYPC,MAdf,SAAchB,GAAO,IACXiB,EAASjB,EAATiB,KACR,OACEf,EAAAC,EAAAC,cAAA,MAAIC,UAAU,QACZH,EAAAC,EAAAC,cAAA,MAAIC,UAAU,cAAcY,EAAKC,MACjChB,EAAAC,EAAAC,cAACe,EAAD,CAAST,OAAQO,EAAKP,WC6BbU,qBAjCb,SAAAA,EAAYpB,GAAM,IAAAqB,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAX,KAAAS,IAChBC,EAAAC,OAAAE,EAAA,EAAAF,CAAAX,KAAAW,OAAAG,EAAA,EAAAH,CAAAF,GAAAM,KAAAf,KAAMX,KACD2B,MAAQ,CACXC,MAAO,IAETP,EAAKQ,UALWR,yEAQR,IAAAS,EAAAnB,KACRoB,MAAM,yGACLC,KAAK,SAAAC,GAAQ,OAAIA,EAASC,SAC1BF,KAAK,SAAAf,GACJa,EAAKK,SAAS,CAACP,MAAOX,EAAKmB,8CAKtB,IACCR,EAAUjB,KAAKgB,MAAfC,MAER,OACE1B,EAAAC,EAAAC,cAAA,OAAKC,UAAU,OACfH,EAAAC,EAAAC,cAAA,MAAIC,UAAU,SACTuB,EAAMhB,IAAI,SAACyB,EAAMC,GAAP,OACXpC,EAAAC,EAAAC,cAACmC,EAAD,CAAMzB,IAAKwB,EAAKrB,KAAMoB,eAzBdG,IAAMzB,YCQJ0B,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCXNC,IAASC,OAAO7C,EAAAC,EAAAC,cAAC4C,EAAD,MAASC,SAASC,eAAe,SD0H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMrB,KAAK,SAAAsB,GACjCA,EAAaC","file":"static/js/main.e5dff73d.chunk.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport './ColorSquare.scss';\n\nfunction ColorSquare(props) {\n  const { color } = props;\n  return (\n    <li\n      className=\"ColorSquare\"\n      style={{\n        backgroundColor: `#${color}`\n      }}\n    />\n  );\n}\n\nColorSquare.propTypes = {\n  color: PropTypes.string.isRequired\n};\n\nexport default ColorSquare;\n//ColorSquare es el li. ¿Que no tiene disponible y necesita? colors: pues de las props vamos a decirle que en las props hay una clave colors que yo voy a guardar en una constante colors\n\n//¿en color square porque hace falta sacar coor si ya lo tienes sacado? Hace falta volver a sacar color porque props es un objeto, con tantos atributos como yo le saque a colors square. Por ejemplo si yo le doy size:l porque quiero pintar ccuadros grande sy pequeños, en props vendran dos claves, size y colors. props es un objeto, siempre siempre. Si le quito el size sigue siendo un objeto con una sola clave, color. A Nasi no le encanta loguear porque cuando e sun componente que se renderiza muchas veces al consola se queda muy sucia, le gusta mas decir, palette, a este color square que le llega.\n\n//Podriamos poner los estilos de cada componente, vamos a hacer al menos el de el cuadrado.\n\n","\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport ColorSquare from './ColorSquare';\nimport './Palette.scss';\n\nclass Palette extends Component {\n  render() {\n    const { colors } = this.props;\n    return (\n      <ol className=\"Palette\">\n        {colors.map(color => (\n          <ColorSquare key={color} color={color} />\n        ))}\n      </ol>\n    );\n  }\n}\n\nPalette.propTypes = {\n  colors: PropTypes.arrayOf(PropTypes.string.isRequired).isRequired\n};\n\nexport default Palette;\n\n\n//function Palette ({props}){\n    // const { colors } = props;\n    // esto son las props y de las props saco la constante colors y la guardao en una consttante llamada colors","import React from 'react';\nimport PropTypes from 'prop-types';\nimport Palette from './Palette';\n\nfunction Ship(props) {\n  const { data } = props;\n  return (\n    <li className=\"Ship\">\n      <h2 className=\"Ship__name\">{data.name}</h2>\n      <Palette colors={data.colors} />\n    </li>\n  );\n}\n\nShip.propTypes = {\n  data: PropTypes.object.isRequired\n};\n\nexport default Ship;\n\n\n\n//creo un componennte ship. ship tiene que retornar el li. ¿Para poder retornar el li que le tiene que llegar por props? el dato ship. \n//Si yo simplemente lo copio y lo pego en el componente no vale, se lo tengo que pegar por props. \n\n//Le pongo const {ship} = props;\n\n//como esto empieza a ser un componente complejo creo sus instrucciones con el propTypes\n\n//ahora vamos a hacer otro componente Palette\n//en ship quiero ahora pintar el componente Palette, a la cual le llega un array de colors, entonces le digo constante colors = {data.colors} -->  <Palette colors = {data.colors}/>","import React from 'react';\nimport Ship from \"./components/Ship\";\nimport './App.scss';\n\nclass App extends React.Component {\n  constructor(props){\n    super(props);\n    this.state = {\n      ships: []\n    };\n    this.getData();\n  }\n\n  getData() {\n    fetch('https://raw.githubusercontent.com/Adalab/Easley-ejercicios-de-fin-de-semana/master/data/palettes.json')\n    .then(response => response.json())\n    .then(data => {\n      this.setState({ships: data.palettes});\n    })\n  }\n  \n\n  render() {\n    const { ships } = this.state;\n\n    return (\n      <div className=\"App\">\n      <ul className=\"Ships\">\n          {ships.map((item, ind) => (\n          <Ship key={ind} data={item} />\n          )\n          )}\n      </ul>\n      </div>\n    );\n  }\n}\n\nexport default App\n\n//¿Qué he hecho hasta ahora? \n\n//Ships es un objeto y lo saco de las props. Es un objeto, un array. Cojo mi array, del objeto props. En mi componente App hay un objeto props, este objeto props tiene una clave ships que dentro tiene un array y esto es lo que estoy cogiendo.\n\n//El map es como una for. El map a cada objeto le creo una funcion y crea un arary en vez de objetos, me crea un array de lis.\n\n//Seguimos. En ships.map tenia objetos, con un name que ya lo he pintado y a su vez una clave colors que contiene un array de colores. \n//Es exactmente lo mismo otra vez.\n\n//Vamos a meter el nombre en un h2 y voy a meter los colores en un ol, porque la paleta esta ordenada. \n\n//Quiero tantos li como colores haya, pero tengo que volver a hacer un map -> ship.colors.map. ¿Porque tengo que volver a hacer otro map? Porque estoy dentro de cada item, y aqui tengo una clave colors que tiene de nuevo un array, es como un for dentro de un for.\n\n//Me llega una clave colors y quiero pintar un li con un style. style en react acepta un objeto, por tanto, quiero ponerle en la clave background color el valor que me llega en color y le ponga la almohadilla porque es un hexadecimal. ademas le damos una clase que le de la altura y la anchura, pero dfe momento se la damos en el objeto del style y luego la llevamos a la clase: height: 30px, width: 30px; \n\n//Ya esta, tengo un li en cuyo atributo de react\n\n//cuando las clases en css tiene unn guion, reatc nos dice, como es un objeto las palabras compuestas pasalas a camelCase.\n\n//ya tenemos el componente Ship, Palette y ahora vamos a por ColorSquare, para ver como partir y partir elementos.\n\n//que es this? si yo tengo aqui un atributo. Render es un metodo de un objeto, en este caso de la calse App. la clase App es un constructor de objetos como este. si yo quiero aceder a un atributo que haya llamado en la clase lo llamo con this (this.name, por ejemplo)\n\n\n// Nosotros esttamos extendiendo de component. En el component reactc ha creado props vacios y state vacio\n\n\n// Al extender la clase de React.Component la magia es que mi clase ahora es como component, osea:\n\n\n// class App extend React.Componente {\n\n//   props = {\n\n//   }\n\n//   state = {\n\n//   }\n//   render () {\n\n//     return (\n\n//     )\n//   }\n// }\n\n//la magia de react es que en tre el punto en que yo pinto el componente, el por debajo coge y props y state lo enchufa.\n\n// class App extends React.Component {\n// props = {\n//   ships: []\n// }\n//props es un atributo y tiene dentro la clave ships que es un array --> esto es lo que hace react por nosotras. Si tu aqui en el index.js cuando llamas a App en reactDOM.render cuando instancias le pones un atributo llamado ships, va a hacer esto. No lo vemos, pero hace esto.\n\n\n//QUEREMOS QUE SE HAGA EL FETCH UNA VEZ Y AL PRINCIPIO. ¿que metodo de la clase se ejecuta solo una vez y al principio? el constructor. por tanto el cosntrutor me encaja genial para esto. de mommento si, ya veremos mas adelante donde.\n\n//Vamos a hacermos otro metodo getdata que haga el fetch y lo vamos a llamar en el constructor al metodo. Get data hace un ftech de la url, cuando llegan los datos los parsea a json y en el siguiente then, le llega data y tenemos dos claves: version y paletes. \n\n//¿Que vamos a hacer? lo sacabamos de props. pero ahora no va a venir desde la madre, ella misma, la madre lo va a pedir por un fetch y lo va a guardar en su estado. \n\n//ships inicialmente es un array vacio y cuando data conteste: ships.sestate y que la clave ships tenga data.palettes\n\n//en render aqui vamos a deir, en lugar de ships de las props, ships del estado\n\n//ahora hemos reado una funcion que hace un fetch y el resultado lo guarda en ele stado. donde hemos llamado a este metodo? en ningun sitio aun --> hemos dicho que lo queriamos llammar una vez y al inicio\n\n\n//¿No hay que hacer bind? Vale, ¿quien ejeuta this.state? GetData. Y esta funcion es ejecutada por nosotros? No, es ejecutada por el then, por tanto ->\n//SI HAY QUE BINDEAR, pero como yo me he marcado un arrwo funtion no hay que bindear, porque el arrow tiene this lexico y no hay que bindear. Pero si hago funtion sin arrows si tengo que poner el bind\n\n\n//Si tienes varios metodos que necesitan varios bindeados, haras tantos como necesites. aqui solo hay getdata, pero si hubiese mas y tienes que bindearlos, pones tantos bind.this como necesites\n\n// return (\n//   <div className=\"App\">\n//   <ul className=\"Ships\">\n//       {ships.map((item, ind) => (\n//       <Ship key={ind} data={item} />\n//           //al componenete ship le va a llegar data que es un objeto y en data vamos a enchufar el item de esta vuelta de lis\n//         )\n//       })}\n//   </ul>\n//   </div>","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}